#!/usr/bin/env python3
"""
Generate Material Symbols icon maps (JSON + Python constants).

The script can ingest multiple sources:
    * Upstream metadata JSON
    * Material Symbols `.codepoints` files
    * TTF/OTF fonts (via fontTools)

Outputs:
    * JSON map (name -> hex codepoint string) for tooling/tests
    * Optional Python module containing Symbol dataclass constants and
        lazy lookup helpers (Icons.favorite-style usage)

Usage examples:
    python scripts/vendor/material/generate_icon_map.py \
        --codepoints src/nuiitivet/material/symbols/MaterialSymbolsOutlined[FILL,GRAD,opsz,wght].codepoints \
        --python-out src/nuiitivet/material/symbols/material_symbols.py
    python scripts/vendor/material/generate_icon_map.py \
        --font src/nuiitivet/material/symbols/MaterialSymbolsOutlined[FILL,GRAD,opsz,wght].ttf \
        --out src/nuiitivet/material/symbols/icons_map.json

If fontTools is not installed, the script will instruct how to install it
when parsing font files.
"""
from __future__ import annotations

import argparse
import json
import os
import re
import sys
import keyword
from typing import Dict, Optional, Tuple

try:
    from fontTools.ttLib import TTFont  # type: ignore import
except Exception:  # pragma: no cover - optional dependency
    TTFont = None  # type: ignore[assignment]

PY_HEADER = """"""
# Auto-generated by scripts/generate_icon_map.py
# Do not edit manually.
""""""


def sanitize_identifier(name: str) -> str:
    ident = name.lower()
    replacements = {
        "-": "_",
        " ": "_",
        "\t": "_",
        "/": "_",
        "+": "_plus_",
        "&": "_and_",
    }
    for old, new in replacements.items():
        ident = ident.replace(old, new)
    while "__" in ident:
        ident = ident.replace("__", "_")
    ident = ident.strip("_")
    if not ident:
        ident = "symbol"
    if ident[0].isdigit():
        ident = f"_{ident}"
    if keyword.iskeyword(ident):
        ident = f"{ident}_"
    if not ident.isidentifier():
        ident = "_" + "".join(ch if ch.isalnum() or ch == "_" else "_" for ch in ident)
    return ident


def codepoint_literal(cp: int) -> str:
    if cp <= 0xFFFF:
        return f"\\u{cp:04X}"
    return f"\\U{cp:08X}"


def load_metadata(path: str) -> Dict[str, int]:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    out: Dict[str, int] = {}
    # expect mapping name->codepoint or list of records
    if isinstance(data, dict):
        for k, v in data.items():
            try:
                out[k] = int(v, 0) if isinstance(v, str) else int(v)
            except Exception:
                continue
    elif isinstance(data, list):
        for rec in data:
            # try common shapes {name:..., codepoint:...}
            if not isinstance(rec, dict):
                continue
            name = rec.get("name") or rec.get("icon")
            cp = rec.get("codepoint") or rec.get("code")
            if name and cp:
                try:
                    out[name] = int(cp, 0) if isinstance(cp, str) else int(cp)
                except Exception:
                    continue
    return out


def parse_font_map(font_path: str) -> Dict[str, int]:
    if TTFont is None:
        print("fontTools is required to parse fonts. Install with: pip install fonttools", file=sys.stderr)
        raise ImportError("fontTools not installed")

    tt = TTFont(font_path, recalcBBoxes=False, recalcTimestamp=False)

    # build codepoint -> glyphName map from cmap
    cmap = {}
    for table in tt["cmap"].tables:
        if table.isUnicode():
            cmap.update(table.cmap)

    # attempt to use post or glyphOrder to map glyph names to readable names
    # glyph_order available via tt.getGlyphOrder() if needed for heuristics
    _ = tt.getGlyphOrder()

    # heuristics: if glyph name is not like 'uniXXXX' then consider it a candidate name
    name_map: Dict[str, int] = {}
    uni_re = re.compile(r"^(uni|u)[0-9A-Fa-f]{3,6}$")

    for codepoint, glyphName in cmap.items():
        if not glyphName:
            continue
        # skip automatic uniXXXX names
        if uni_re.match(glyphName):
            # try to see if glyphName appears in glyph order as something meaningful
            continue
        # normalize glyphName to a friendly name if possible
        friendly = glyphName
        # some glyph names use hyphens/underscores; keep them
        # store mapping name -> codepoint
        name_map[friendly] = codepoint

    # fallback: if no friendly names found, attempt to extract from glyph order
    if not name_map:
        for codepoint, glyphName in cmap.items():
            # try to map glyphName like 'gid123' or 'glyph123' -> skip
            if glyphName and not uni_re.match(glyphName):
                name_map[glyphName] = codepoint

    tt.close()
    return name_map


def write_json_map(out_path: str, mapping: Dict[str, int]) -> None:
    # convert ints to hex strings for readability
    out = {name: hex(cp) for name, cp in sorted(mapping.items())}
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(out, f, ensure_ascii=False, indent=2)


def load_codepoints_file(path: str) -> Dict[str, int]:
    mapping: Dict[str, int] = {}
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            if len(parts) < 2:
                continue
            name, hex_cp = parts[0], parts[1]
            try:
                mapping[name] = int(hex_cp, 16)
            except Exception:
                continue
    return mapping


def write_python_module(
    out_path: str,
    mapping: Dict[str, int],
    class_name: str = "Symbols",
    symbol_type_name: str = "Symbol",
) -> None:
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    sorted_items = sorted(mapping.items())

    identifier_records: list[Tuple[str, str, int]] = []
    ident_counts: Dict[str, int] = {}
    for name, cp in sorted_items:
        base_ident = sanitize_identifier(name)
        count = ident_counts.get(base_ident, 0)
        ident_counts[base_ident] = count + 1
        ident = base_ident if count == 0 else f"{base_ident}_{count+1}"
        identifier_records.append((ident, name, cp))

    lines: list[str] = []
    lines.append("from __future__ import annotations\n\n")
    lines.append("from dataclasses import dataclass\n")
    lines.append("from typing import ClassVar, Dict\n\n\n")
    lines.append("@dataclass(frozen=True)\n")
    lines.append(f"class {symbol_type_name}:\n")
    lines.append('    """Material symbol descriptor."""\n')
    lines.append("    name: str\n")
    lines.append("    codepoint: str\n\n")
    lines.append("    def ligature(self) -> str:\n")
    lines.append("        return self.name\n\n")
    lines.append("    def glyph(self) -> str:\n")
    lines.append("        return self.codepoint\n\n\n")
    lines.append(f"class {class_name}:\n")
    lines.append('    """Material Symbols constants (auto-generated)."""\n')

    for ident, name, cp in identifier_records:
        literal = codepoint_literal(cp)
        single_line = f'    {ident}: {symbol_type_name} = {symbol_type_name}(name="{name}", codepoint="{literal}")\n'
        if len(single_line) <= 120:
            lines.append(single_line)
        else:
            lines.append(
                f"    {ident}: {symbol_type_name} = {symbol_type_name}(\n"
                f'        name="{name}",\n'
                f'        codepoint="{literal}",\n'
                "    )\n"
            )

    lines.append("\n    _NAME_TO_SYMBOL: ClassVar[Dict[str, " + symbol_type_name + "] | None] = None\n")

    lines.append(
        "\n    @classmethod\n    def _index(cls) -> Dict[str, "
        + symbol_type_name
        + "]:\n        mapping = cls._NAME_TO_SYMBOL\n        if mapping is None:\n            mapping = {\n"
        "                value.name: value\n"
        "                for value in cls.__dict__.values()\n"
        "                if isinstance(value, "
        + symbol_type_name
        + ")\n            }\n            cls._NAME_TO_SYMBOL = mapping\n        return mapping\n"
    )

    lines.append(
        "\n    @classmethod\n    def from_name(cls, name: str | None) -> "
        + symbol_type_name
        + " | None:\n        if not name:\n            return None\n        return cls._index().get(name)\n"
    )

    lines.append(
        "\n    @classmethod\n"
        "    def glyph_for(cls, name: str | None) -> str | None:\n"
        "        symbol = cls.from_name(name)\n"
        "        return symbol.codepoint if symbol else None\n"
    )

    lines.append("\n\n__all__ = (\n")
    lines.append('    "' + symbol_type_name + '",\n')
    lines.append('    "' + class_name + '",\n')
    lines.append(")\n")

    content = PY_HEADER + "\n" + "".join(lines)
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(content)


def main(argv: Optional[list] = None) -> int:
    p = argparse.ArgumentParser(description="Generate icon name -> codepoint map")
    p.add_argument("--font", help="Path to font file (ttf/otf)")
    p.add_argument("--metadata", help="Optional metadata JSON from upstream to use as source")
    p.add_argument(
        "--codepoints",
        action="append",
        help="Material Symbols .codepoints file (can be passed multiple times)",
    )
    p.add_argument(
        "--out",
        default="src/nuiitivet/material/symbols/icons_map.json",
        help="Output JSON file",
    )
    p.add_argument(
        "--python-out",
        default="src/nuiitivet/material/symbols/material_symbols.py",
        help="Optional Python module output path",
    )
    p.add_argument("--python-class-name", default="Symbols", help="Class name for constants")
    p.add_argument(
        "--symbol-type-name",
        default="Symbol",
        help="Dataclass name for symbol descriptors",
    )
    args = p.parse_args(argv)

    mapping: Dict[str, int] = {}

    if args.codepoints:
        for cp_file in args.codepoints:
            if not os.path.isfile(cp_file):
                print(f"Codepoints file not found: {cp_file}", file=sys.stderr)
                return 2
            cp_map = load_codepoints_file(cp_file)
            mapping.update(cp_map)
            print(f"Loaded {len(cp_map)} entries from codepoints {cp_file}")

    if args.metadata:
        if not os.path.isfile(args.metadata):
            print(f"Metadata file not found: {args.metadata}", file=sys.stderr)
            return 2
        mapping = load_metadata(args.metadata)
        print(f"Loaded {len(mapping)} entries from metadata {args.metadata}")

    if args.font:
        if not os.path.isfile(args.font):
            print(f"Font file not found: {args.font}", file=sys.stderr)
            return 2
        try:
            font_map = parse_font_map(args.font)
            print(f"Parsed {len(font_map)} glyph-name entries from font {args.font}")
        except Exception as e:
            print(f"Failed to parse font: {e}", file=sys.stderr)
            return 3
        # merge: prefer metadata entries over font_map
        for name, cp in font_map.items():
            if name not in mapping:
                mapping[name] = cp

    if not mapping:
        print("No mapping data produced.", file=sys.stderr)
        return 4

    out_path = args.out
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    write_json_map(out_path, mapping)
    print(f"Wrote icon map with {len(mapping)} entries to {out_path}")

    if args.python_out:
        write_python_module(
            args.python_out,
            mapping,
            class_name=args.python_class_name,
            symbol_type_name=args.symbol_type_name,
        )
        print(f"Wrote Python constants module to {args.python_out}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
