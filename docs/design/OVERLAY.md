# Overlay System Design

## 1. Core Architectural Structure

### 1.1 Relationship Between Overlay and Navigator

#### Policy: Physical Separation + Shared Internal Implementation

The user-facing API should intuitively reflect the physical structure, while internal route/stack management is shared.

- `Overlay.show()` to "display on the topmost layer"
- `Navigator.push()` to "transition screens" (see [docs/design/NAVIGATION.md](NAVIGATION.md) for details)

Internally, the `Overlay` maintains an internal stack (e.g., `_modal_navigator`) to manage active overlay entries (and Routes if necessary).

Note: The `Overlay` core provides only `show()`, while scenario-specific APIs (dialogs, snackbars, etc.) are delegated to subclasses.

#### Design Intent (Separation and Sharing)

- Use an API that makes it intuitively clear where things are rendered from a user's perspective.
  - `Overlay.show()` is always on top.
  - `Navigator.push()` is for screen transitions.
- At the same time, share internal implementation for Route and stack management to avoid duplication for different display scenarios (dialog, snackbar, page, etc.).

"Dialog/Snackbar" are conceptual examples; technically, they are treated as overlay entries (containing Routes) generated by `Overlay.show()`.

```text
┌─────────────────────────────────────┐
│ App                                  │
│                                      │
│  ┌───────────────────────────────┐  │
│  │ Overlay (Physical Layer)       │  │ ← Always on top
│  │  Internal: _modal_navigator   │  │
│  │    └─ OverlayEntry/Route      │  │
│  └───────────────────────────────┘  │
│                                      │
│  ┌───────────────────────────────┐  │
│  │ Content                       │  │
│  │  ┌──────────────────┐         │  │
│  │  │ Navigator (Part) │         │  │ ← Placed by user
│  │  │  ├─ PageRoute    │         │  │
│  │  │  └─ PageRoute    │         │  │
│  │  └──────────────────┘         │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

## 2. Overlay API Design

### 2.1 API Consistency with Navigator

- `App` provides a root Overlay and a global access API.
- `IOverlay` is provided to ensure ViewModels do not depend on implementation details.
  - `Overlay.of(context)`: Nearest Overlay.
  - `Overlay.root()`: Root Overlay.

### 2.2 Overlay Core provides only `show()`

- `Overlay` provides only a generic `show()` and no scenario-specific APIs like `dialog`, `snackbar`, or `sheet`.
- `Overlay.show()` accepts only `Widget | Route`.
- Intent resolution (`Intent -> Widget/Route`) is not performed by `Overlay`.
- Intent resolution is provided by subclasses (e.g., `MaterialOverlay`) using an `IntentResolver`.

### 2.3 `Overlay.show()` Core API

`Overlay.show()` is the minimal core API for displaying content on the topmost layer.

```python
def show(
    self,
    content: Widget | Route,
    *,
    passthrough: bool = False,
    dismiss_on_outside_tap: bool = False,
    timeout: float | None = None,
    position: OverlayPosition | None = None,
) -> OverlayHandle[Any]:
    ...
```

#### Parameters

- `passthrough=False`
  - `False`: The Overlay consumes pointer events and blocks input to the layers behind it.
  - `True`: The Overlay passes events through to layers below.
- `dismiss_on_outside_tap=False`
  - `True`: Closes the overlay when tapping outside the displayed content.
- `timeout: float | None`
  - Duration in seconds.
  - `None`: Does not automatically close.
- `position: OverlayPosition | None`
  - `None` is equivalent to "center".

#### Constraints

- `passthrough=True` and `dismiss_on_outside_tap=True` are mutually exclusive (`ValueError`).

#### Definition of "Outside-tap"

- "Outside" is defined based on the hit-testing rules in [BOX_MODEL.md](BOX_MODEL.md).
- Outside-tap dismissal is achieved by closing when the barrier layer receives a pointer event.
- If the content covers the entire viewport, outside-tap dismissal will not function.

### 2.4 Positioning: `OverlayPosition` (v1)

v1 provides only alignment and offset.

- `OverlayPosition.alignment(alignment: str, *, offset: tuple[float, float] = (0, 0))`

`alignment` follows the vocabulary for single-child alignment defined in [LAYOUT.md](LAYOUT.md).

- `"top-left"`, `"top-center"`, `"top-right"`
- `"center-left"`, `"center"`, `"center-right"`
- `"bottom-left"`, `"bottom-center"`, `"bottom-right"`

`offset` is applied after alignment.

- Unit: px.
- Coordinate system is the overlay root's layout space.
  - $+x$ is right.
  - $+y$ is down.

### 2.5 `OverlayHandle` / `OverlayResult`

`Overlay.show()` returns an `OverlayHandle[T]`.

- `handle.close(value)` closes the specific entry associated with the handle.
- `await handle` returns a structured result.

```python
class OverlayResult[T]:
    value: T | None
    reason: OverlayDismissReason


class OverlayDismissReason(Enum):
    CLOSED = ...
    OUTSIDE_TAP = ...
    TIMEOUT = ...
    DISPOSED = ...
```

#### Result Semantics

- `handle.close(value)` -> `OverlayResult(value=value, reason=CLOSED)`
- Outside-tap -> `OverlayResult(value=None, reason=OUTSIDE_TAP)`
- Timeout -> `OverlayResult(value=None, reason=TIMEOUT)`
- Entry discarded without explicit close -> `OverlayResult(value=None, reason=DISPOSED)`

`await handle` is guaranteed not to wait indefinitely (even completed on disposal).

### 2.6 Subclass APIs (MaterialOverlay, etc.)

Scenario-specific APIs are moved to subclasses.

#### Responsibilities of MaterialOverlay

`MaterialOverlay` is implemented as a subclass of `Overlay` and provides Material-specific resolution and shortcut APIs.

- Inheritance: `MaterialOverlay(Overlay)`
- Retrieval:
  - `MaterialOverlay.root()` succeeds only if the root overlay is a `MaterialOverlay`.
  - `MaterialOverlay.of(context)` searches the widget tree for the nearest `MaterialOverlay`.

#### Intent Resolution

- `MaterialOverlay.dialog(...)` accepts `Widget | Route | Any`.
  - `Widget | Route` is displayed as-is.
  - Everything else is resolved to `Widget | Route` via `IntentResolver.resolve(intent)`.
- `MaterialOverlay` allows for `IntentResolver` injection.
  - Alternatively, pass `intents: Mapping[type[Any], Callable[[Any], Widget | Route]]` (internally builds a mapping resolver).
- Register standard intents by default:
  - `AlertDialogIntent`
  - `LoadingDialogIntent`

#### Provided APIs (v1)

- `MaterialOverlay.dialog(...)`
  - Blocks background input by default (`passthrough=False`).
  - `dismiss_on_outside_tap` is optional.
    - Default is `False` for `LoadingDialogIntent`.
    - Default is `True` for others.
- `MaterialOverlay.snackbar(message, *, duration=3.0)`
  - Implemented using `Snackbar`.
  - Transparent to background input by default (`passthrough=True`).
  - Automatically dismisses after `timeout=duration`.
  - Default position: `OverlayPosition.alignment("bottom-center", offset=(0, -24))`.
- `MaterialOverlay.loading(message="Loading...")`
  - Displays `LoadingDialogIntent` and ensures it closes upon exiting a context manager.

### 2.7 Swapping the Root Overlay: `overlay_factory`

To allow Material apps to use `MaterialOverlay` as the root overlay, `App` allows for overlay injection.

- `App` / `App.navigation()` accepts `overlay_factory: Callable[[], Overlay]`.
- If omitted, `App` defaults to creating a standard `Overlay`.

Example:

```python
app = App(
    overlay_factory=lambda: Overlay(),
)
```

```python
app = MaterialApp(
    overlay_factory=lambda: MaterialOverlay(),
)
```

In the Material implementation, `MaterialApp` sets `overlay_factory` internally and passes `overlay_routes` to `MaterialOverlay(intents=...)` as needed.

### 2.8 Note: Scope of `Overlay.show()`

- `Overlay.show()` is not responsible for intent registration or providing standard dialog/widgets.
- Standard UI components (e.g., `AlertDialog`, `LoadingDialog`) and intents are provided by `MaterialOverlay`.

## 3. Asynchronous Processing and Lifecycle

- For the big picture (threads × asyncio × UI thread), see [CONCURRENCY_MODEL.md](CONCURRENCY_MODEL.md).
- Details on the execution foundation (async runtime) and event loop integration are centralized in [ASYNCIO_INTEGRATION.md](ASYNCIO_INTEGRATION.md).
- The Overlay's responsibility is to ensure that `await handle` never hangs.
  - If an entry is removed without being explicitly closed, it completes with `OverlayDismissReason.DISPOSED`.
  - The caller can branch based on `OverlayResult.reason`.

## 4. Z-Index and Rendering Order

### 4.1 Rendering Order Design

Rendering order is controlled by insertion order (later entries are rendered on top), eliminating the need for explicit Z-index management.

#### Design Intent (Rendering Order)

- Managing numerical Z-index values adds complexity that is unnecessary for initial requirements (YAGNI).
- Matching the intuition that "later openings are on top" aligns with user expectations and consistency with other frameworks like Flutter.

```python
class Overlay(Widget):
    def __init__(self):
        self._entries: list[OverlayEntry] = []

    def _insert_entry(self, entry: OverlayEntry):
        self._entries.append(entry)
        self.mark_needs_layout()

    def build(self, context):
        return Stack(children=[entry.builder() for entry in self._entries])
```

## 5. Integration with Back / Navigator

Details on Back button priority and `will_pop` are centralized in [docs/design/NAVIGATION.md](NAVIGATION.md).

- The Overlay focus is solely on closing the topmost overlay entry.
- `Overlay.close(...)` is provided as a shortcut to close the topmost entry.

## Pending Matters / Future Considerations

The following items are not finalized in this specification (or require implementation/verification).

### Async / Runtime

- Current behavior is defined in [docs/design/ASYNCIO_INTEGRATION.md](ASYNCIO_INTEGRATION.md).
- Handling strategy for `asyncio.CancelledError`.
- Implementation of Future cancellation notification.
- Policy for error logging (what users should see).
- How to launch coroutines from UI events (integration with the execution foundation).

### ViewModel / Dispose

- Providing helpers like `CompositeDisposable`.
- Organizing ViewModel lifecycle management patterns.
- Mechanism for automatic ViewModel disposal.
- Best practices for the relationship between ViewModels and Widgets.
- Guarding operations on already disposed Widgets.
- Managing state flags after disposal.
- Preventing double calling of `dispose`.

### Rendering / Overlay

- Scoped Overlay
  - Rendering order (below or above the App Overlay?).
  - Order control between Scoped Overlays.
- Design for introducing Z-index in the future.
- Maintaining compatibility (existing code continues to work).
- Rendering optimizations for large numbers of Overlays.
- Skipping rendering for non-visible Overlays.
Details on Back Button / Events are centralized in [docs/design/NAVIGATION.md](NAVIGATION.md).

### Documentation / Prototype

- Finalize the core design of the Intent System.
- Evaluate implementation strategies for Context Lookup.
- Evaluate implementation strategies for asynchronous processing.
- Evaluate implementation strategies for Z-index management.
- Create class and sequence diagrams.
- Draft API references.
- Prioritize implementation tasks and create issues.
- Develop a minimal prototype and identify potential issues.
- Refine the design based on feedback.
